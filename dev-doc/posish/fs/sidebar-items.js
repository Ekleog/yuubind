initSidebarItems({"enum":[["Advice","`POSIX_FADV_*` constants."],["FileType","`S_IF*` constants."]],"fn":[["accessat","`faccessat(dirfd, path, access, flags)`"],["chmodat","`fchmodat(dirfd, path, mode, 0)`"],["copy_file_range","`copy_file_range(fd_in, off_in, fd_out, off_out, len, 0)`"],["cwd","Return a “file” which holds a handle which refers to the process current directory (`AT_FDCWD`). It is a `ManuallyDrop`, however the caller should not drop it explicitly, as it refers to an ambient authority rather than an open resource."],["fadvise","`posix_fadvise(fd, offset, len, advice)`"],["fchmod","`fchmod(fd)`."],["fstatfs","`fstatfs(fd)`"],["futimens","`futimens(fd, times)`"],["get_seals","`fcntl(fd, F_GET_SEALS)`"],["getfd","`fcntl(fd, F_GETFD)`"],["getfl","`fcntl(fd, F_GETFL)`"],["is_file_read_write","`fcntl(fd, F_GETFL) & O_ACCMODE`. Returns a pair of booleans indicating whether the file descriptor is readable and/or writeable, respectively. This is only reliable on files; for example, it doesn’t reflect whether sockets have been shut down; for general I/O handle support, use [`crate::io::is_read_write`]."],["linkat","`linkat(old_dirfd, old_path, new_dirfd, new_path, flags)`"],["major","`major(dev)`"],["makedev","`makedev(maj, min)`"],["minor","`minor(dev)`"],["mkdirat","`mkdirat(fd, path, mode)`"],["openat","`openat(dirfd, path, oflags, mode)`"],["openat2","`openat2(dirfd, path, OpenHow { oflags, mode, resolve }, sizeof(OpenHow))`"],["posix_fallocate","`posix_fallocate(fd, offset, len)`"],["preadv","`preadv(fd, bufs.as_ptr(), bufs.len(), offset)`"],["pwritev","`pwritev(fd, bufs.as_ptr(), bufs.len(), offset)`"],["readlinkat","`readlinkat(fd, path)`"],["renameat","`renameat(old_dirfd, old_path, new_dirfd, new_path)`"],["seek","`lseek(fd, offset, whence)`"],["setfd","`fcntl(fd, F_SETFD, flags)`"],["setfl","`fcntl(fd, F_SETFL, flags)`"],["statat","`fstatat(dirfd, path, flags)`"],["statx","`statx(dirfd, path, flags, mask, statxbuf)`. Note that this isn’t available on older Linux; returns `ENOSYS` in that case."],["symlinkat","`symlinkat(old_dirfd, old_path, new_dirfd, new_path)`"],["tell","`lseek(fd, 0, SEEK_CUR)`"],["unlinkat","`unlinkat(fd, path, flags)`"],["utimensat","`utimensat(dirfd, path, times, flags)`"]],"struct":[["Access","`*_OK` constants for use with `accessat`."],["AtFlags","`AT_*` constants."],["Dir","`DIR*`"],["Entry","`struct dirent`"],["FdFlags","`FD_*` constants."],["Mode","`S_I*` constants."],["OFlags","`O_*` constants."],["ResolveFlags","`RESOLVE_*` constants."],["SeekLoc","A location for use with `Dir::seek`."]],"trait":[["DirEntryExt","Re-export types common to Posix-ish platforms."],["FileExt","Re-export types common to Posix-ish platforms."],["FileTypeExt","Re-export types common to Posix-ish platforms."],["MetadataExt","Re-export types common to Posix-ish platforms."],["OpenOptionsExt","Re-export types common to Posix-ish platforms."]],"type":[["LibcStat","Re-export `libc::stat` (or `libc::stat64` where applicable)."],["LibcStatFs","Re-export `libc::statfs` (or `libc::statfs64` where applicable)."],["LibcStatx","Re-export `libc::statx`. Only available on Linux with GLIBC for now."]]});